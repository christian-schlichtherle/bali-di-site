---
actionLink: /guide/java.md
actionText: Quick Start →
heroImage: /image/frangipani.png
features:
- title: Compile-time bindings
  details: Dependency bindings are type-checked by the compiler and if any dependency is missing or incompatible, an error message is emitted.
- title: Named dependencies
  details: Dependencies are named, so that the compiler can always discern a dependency named "foo" from a "bar", even if they have the same type.
- title: Just-in-time resolution
  details: Dependencies are created and (if desired) cached just-in-time by calling abstract methods, so that your application can startup quickly.
- title: No runtime artifacts
  details: All necessary code is generated by the compiler, so that there are no runtime artifacts, and it doesn't break byte code analysis or transformation tools.
- title: Simple and scalable
  details: Dependencies are defined in module contexts or types. Module types can get composed into large systems by composition or inheritance. 
- title: Supports Java and Scala
  details: Bali DI is implemented as an annotation processor in Java and as a def macro in Scala. You can even use it in mixed Java/Scala/Scala.js projects.
- title: Mix & match with JSR 330
  details: Bali DI is completely complementary to Spring, Guice, Macwire, CDI or any other JSR 330 implementation, so that you can use both in the same project.
- title: No IDE plugin required
  details: The Java annotation processor emits formatted source code, so that you can easily inspect your dependency bindings and their caching.
- title: Effectively eliminates `new`
  details: The design is based on abstract types, which are hard to implement manually. This is an effective deterrent to accidentally `new` a dependency type.
footer: Apache License, Version 2.0 | Copyright © Schlichtherle IT Services
home: true
tagline: Modern compile-time dependency injection with just-in-time resolution for Java, Scala and Scala.js.
---
